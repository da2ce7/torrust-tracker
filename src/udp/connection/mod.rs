
//! Connection ID is a value generated by the tracker and sent to the client
//! to avoid the client spoofing it's source IP address.
//!
//! Detailed info in [BEP 15](https://www.bittorrent.org/beps/bep_0015.html)
//!
//! In order for the client to connect to the tracker, it must send a connection ID
//! previously generated by the server.
//!
//! The client has to send a "connect" request:
//!
//! | Offset | Size           | Name           | Value                           |
//! |--------|----------------|----------------|---------------------------------|
//! | 0      | 64-bit integer | protocol_id    | 0x41727101980 // magic constant |
//! | 8      | 32-bit integer | action         | 0             // connect        |
//! | 12     | 32-bit integer | transaction_id |                                 |
//! | 16     |                |                |                                 |
//!
//! And it receives a Connection ID in the response:
//!
//! | Offset | Size           | Name           | Value        |
//! |--------|----------------|----------------|--------------|
//! | 0      | 32-bit integer | action         | 0 // connect |
//! | 4      | 32-bit integer | transaction_id |              |
//! | 8      | 64-bit integer | connection_id  |              |
//! | 16     |                |                |              |
//!
//! The client has to send the Connection ID in all subsequent requests.
//! The tracker verifies the connection_id and ignores the request if it doesn't match.
//!
//! From the BEP 15 specification a Connection ID:
//!
//! - Should not be guessable by the client.
//! - Can be used for multiple requests.
//! - Can be used by a client until one minute after it has received it.
//! - Can be accepted by the tracker until two minutes after it has been send.
//!
//! Additionally we define the Connection ID as a value that:
//!
//! - That is unpredictable. The user should not be able to construct their own Connection ID.
//! - That is unique to the the particular connection. Locked to a IP and Port.
//! - That is time bound. It expires after certain time.
//! - That is memoryless. The server doesn't remember what ID's it gave out.
//! - That is stateless. The issuer and the verifier can work interdependently without a dynamic common state.
//!
//! # Why do we need a connection ID?
//!
//! With the Connection ID we check for two things:
//!
//! - The announcing client owns the ip and port it is announcing with.
//! - The announcing client is an online BitTorrent peer.
//!
//! It's a kind of "proof of IP ownership" and "proof of online BitTorrent peer".
//! This makes sure that the client is not a fake client. And it makes harder for attackers
//! to fill the tracker peer list with fake clients.
//!
//! The only way to send an "announce" request is actually being an active and accessible BitTorrent client.
//!
//! It also  avoid clients to send requests on behave of other clients.
//! If there is a legitimate client on the network, attackers could impersonate that client,
//! since they know the IP and port of the legitimate client.
//! An attacker could send an "announce" request for a torrent that the legitimate client does not have.
//! That's a kind of DOS attack because it would make harder to find a torrent.
//! The information about what torrents have each client could be easily manipulated.
//!
//! # Example Implementation
//!
//! Some tracker implementations use a time bound connection ID to avoid storing the connection ID
//! in memory or in the DB.
//!
//! ```text
//! static uint64_t _genCiD (uint32_t ip, uint16_t port)
//! {
//!   uint64_t x;
//!   x = (time(NULL) / 3600) * port; // x will probably overload.
//!   x = (ip ^ port);
//!   x <<= 16;
//!   x |= (~port);
//!   return x;
//! }
//! ```
//!
//! From [here](https://github.com/troydm/udpt/blob/master/src/db/driver_sqlite.cpp#L410-L418).
pub mod secret;
pub mod client_id;
pub mod timestamp_32;
pub mod timestamp_64;
pub mod cypher;
pub mod connection_id_issuer;
